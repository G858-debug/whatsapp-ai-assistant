name: Claude Code Assistant
on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  claude:
    if: contains(github.event.comment.body, '@claude')
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install Dependencies
        run: |
          pip install anthropic
          pip install supabase
          pip install gitpython
      
      - name: Configure Git
        run: |
          git config --global user.name "Claude Assistant"
          git config --global user.email "claude@github-actions.bot"
      
      - name: Save comment to file
        run: |
          cat > comment.txt << 'ENDOFCOMMENT'
          ${{ github.event.comment.body }}
          ENDOFCOMMENT
      
      - name: Process with Claude and Apply Changes
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python - <<'PYTHON_SCRIPT'
          import anthropic
          import os
          import json
          import re
          from pathlib import Path
          import subprocess
          from datetime import datetime
          
          # Read the task
          with open('comment.txt', 'r') as f:
              comment = f.read()
          task = comment.replace('@claude', '').strip()
          
          print(f"üìã Task: {task}")
          
          # Check for special commands
          auto_apply = '@apply' in comment or '@commit' in comment
          create_pr = '@pr' in comment
          force_opus = '@opus' in comment
          force_sonnet = '@sonnet' in comment
          
          # Remove command keywords from task
          clean_task = task.replace('@apply', '').replace('@commit', '').replace('@pr', '')\
                           .replace('@opus', '').replace('@sonnet', '').strip()
          
          # =====================================
          # SMART MODEL SELECTION
          # =====================================
          def select_model_and_context(task, comment):
              """Intelligently select model based on task complexity"""
              
              task_lower = task.lower()
              
              # Force model if specified
              if force_opus:
                  print("üéØ Force flag: Using Opus 4.1")
                  return 'claude-opus-4-1-20250805', 8000, True, "Opus 4.1 (forced)"
              
              if force_sonnet:
                  print("üéØ Force flag: Using Sonnet 3.5")
                  return 'claude-3-5-sonnet-20241022', 4000, False, "Sonnet 3.5 (forced)"
              
              # OPUS 4.1 TRIGGERS (Complex tasks - $15/million tokens)
              opus_triggers = [
                  # Strategic/Architecture
                  'architect', 'strategy', 'strategize', 'design system', 'redesign',
                  'refactor entire', 'complete overhaul', 'restructure', 'plan',
                  
                  # Complex Analysis
                  'analyze entire', 'comprehensive', 'deep dive', 'audit',
                  'optimize performance', 'security audit', 'code review',
                  'review all', 'analyze all', 'investigate',
                  
                  # Multi-file Operations  
                  'entire codebase', 'all files', 'multiple services', 'full system',
                  'complete all', 'fix everything', 'update all', 'every file',
                  
                  # Complex Features
                  'build complete', 'implement full', 'create system', 
                  'complex', 'advanced', 'sophisticated', 'integration',
                  
                  # Chain-of-thought
                  'chain of thought', 'multi-agent', 'step by step analysis',
                  'systematic', 'thorough analysis',
                  
                  # Testing & Documentation
                  'comprehensive tests', 'full documentation', 'test suite',
                  'complete documentation', 'all tests',
                  
                  # Debugging complex issues
                  'debug why', 'trace bug', 'find root cause', 'not working'
              ]
              
              # SONNET 3.5 TASKS (Simple edits - $3/million tokens)
              sonnet_triggers = [
                  # Simple fixes
                  'fix typo', 'update comment', 'add docstring', 'rename',
                  'fix indentation', 'fix syntax', 'fix import', 'indentationerror',
                  
                  # Simple additions
                  'add log', 'add print', 'add comment', 'add todo',
                  'single file', 'one file', 'simple', 'quick',
                  
                  # Specific single-file tasks
                  'update config', 'change constant', 'update variable',
                  
                  # Information queries
                  'list files', 'show structure', 'what files', 'explain',
                  'how many', 'count', 'check'
              ]
              
              # Check triggers
              use_opus = any(trigger in task_lower for trigger in opus_triggers)
              use_sonnet = any(trigger in task_lower for trigger in sonnet_triggers)
              
              # Decision logic
              if use_opus and not use_sonnet:
                  return 'claude-opus-4-1-20250805', 8000, True, "Complex task (Opus 4.1)"
              elif use_sonnet and not use_opus:
                  return 'claude-3-5-sonnet-20241022', 4000, False, "Simple task (Sonnet 3.5)"
              elif len(task) > 200 or task.count('\n') > 3:
                  return 'claude-opus-4-1-20250805', 8000, True, "Long request (Opus 4.1)"
              elif auto_apply and 'all' in task_lower:
                  return 'claude-opus-4-1-20250805', 8000, True, "Multi-file changes (Opus 4.1)"
              else:
                  return 'claude-3-5-sonnet-20241022', 4000, False, "Standard task (Sonnet 3.5)"
          
          # Select model
          selected_model, max_tokens, use_full_context, model_reason = select_model_and_context(task, comment)
          model_name = "Opus 4.1" if "opus" in selected_model else "Sonnet 3.5"
          
          print(f"ü§ñ Model: {model_name}")
          print(f"üìù Reason: {model_reason}")
          
          # =====================================
          # SMART CONTEXT BUILDING
          # =====================================
          def build_smart_context(task, all_files, use_full_context):
              """Build context with only relevant files to save tokens/money"""
              
              task_lower = task.lower()
              
              # Start with file structure (always include - it's cheap)
              context = "=== PROJECT STRUCTURE ===\n"
              for file_path in sorted(all_files.keys()):
                  context += f"- {file_path}\n"
              
              # Full context for Opus complex tasks
              if use_full_context and ('entire' in task_lower or 'all' in task_lower or 'complete' in task_lower):
                  context += "\n\n=== COMPLETE CODEBASE ===\n"
                  total_size = len(context)
                  for file_path, content in sorted(all_files.items()):
                      if total_size + len(content) < 400000:  # ~100k tokens max
                          context += f"\n{'='*60}\nFILE: {file_path}\n{'='*60}\n"
                          context += content
                          context += f"\n{'='*60}\n"
                          total_size += len(content)
                  return context
              
              # Smart selection for specific tasks
              relevant_files = set()
              
              # Core files (always include if small)
              core_files = ['config.py', 'requirements.txt', 'claude.md', 'README.md']
              for f in core_files:
                  if f in all_files and len(all_files[f]) < 5000:
                      relevant_files.add(f)
              
              # Keyword-based file selection
              keyword_mappings = {
                  'payment': ['payment_manager.py', 'services/payment.py', 'payfast_webhook.py'],
                  'assessment': ['services/assessment.py'],
                  'booking': ['services/booking.py'],
                  'whatsapp': ['app.py', 'services/refiloe.py'],
                  'message': ['app.py', 'services/refiloe.py'],
                  'workout': ['services/workout.py'],
                  'dashboard': ['routes/dashboard.py'],
                  'database': ['supabase/migrations'],
                  'migration': ['supabase/migrations'],
                  'error': ['app.py', 'utils/logger.py'],
                  'indentation': ['services/assessment.py'],  # Known problem file
              }
              
              # Check keywords and add relevant files
              for keyword, paths in keyword_mappings.items():
                  if keyword in task_lower:
                      for path in paths:
                          if isinstance(path, str):
                              # Check if it's a directory pattern
                              if '/' in path and not path.endswith('.py'):
                                  # Add all files in that directory
                                  for file_path in all_files.keys():
                                      if path in file_path:
                                          relevant_files.add(file_path)
                              else:
                                  # Direct file
                                  if path in all_files:
                                      relevant_files.add(path)
              
              # Check if specific files are mentioned
              for file_path in all_files.keys():
                  file_name = Path(file_path).stem
                  if file_name in task_lower:
                      relevant_files.add(file_path)
              
              # Default files if nothing specific found
              if len(relevant_files) <= len(core_files):
                  relevant_files.update(['app.py', 'services/refiloe.py'])
              
              # Build context with selected files
              context += f"\n\n=== RELEVANT FILES ({len(relevant_files)} of {len(all_files)}) ===\n"
              
              total_size = len(context)
              max_size = 100000 if "sonnet" in selected_model else 300000
              
              for file_path in sorted(relevant_files):
                  if file_path in all_files:
                      content = all_files[file_path]
                      if total_size + len(content) > max_size:
                          print(f"‚ö†Ô∏è Skipping {file_path} - would exceed context limit")
                          continue
                      context += f"\n{'='*60}\nFILE: {file_path}\n{'='*60}\n"
                      context += content
                      context += f"\n{'='*60}\n"
                      total_size += len(content)
                      print(f"‚úì Including: {file_path}")
              
              return context
          
          # Read all project files
          print("\nüìÇ Reading project files...")
          all_project_files = {}
          
          # Get Python files
          for py_file in Path('.').rglob('*.py'):
              if not str(py_file).startswith('.git'):
                  try:
                      with open(py_file, 'r', encoding='utf-8') as f:
                          all_project_files[str(py_file)] = f.read()
                  except Exception as e:
                      print(f"‚úó Could not read {py_file}: {e}")
          
          # Add other important files
          patterns = ['*.txt', '*.md', '*.yml', '*.yaml', '*.sql', '*.json', '*.toml']
          for pattern in patterns:
              for file in Path('.').rglob(pattern):
                  if not str(file).startswith('.git') and str(file) not in all_project_files:
                      try:
                          with open(file, 'r', encoding='utf-8') as f:
                              all_project_files[str(file)] = f.read()
                      except:
                          pass
          
          print(f"üìö Found {len(all_project_files)} files")
          
          # Build context based on model selection
          context = build_smart_context(clean_task, all_project_files, use_full_context)
          
          # Calculate costs
          estimated_tokens = len(context) / 4
          cost_per_million = 15 if "opus" in selected_model else 3
          estimated_cost = (estimated_tokens / 1_000_000) * cost_per_million
          
          print(f"\nüìä Context size: {len(context):,} chars")
          print(f"ü™ô Estimated tokens: {estimated_tokens:,.0f}")
          print(f"üí∞ Estimated cost: ${estimated_cost:.4f} ({model_name})")
          
          # Cost warning for expensive requests
          if estimated_cost > 0.50:
              print(f"‚ö†Ô∏è WARNING: This request will cost ~${estimated_cost:.2f}")
              if not force_opus:
                  print(f"üí° Tip: Add @sonnet to force Sonnet 3.5 if this isn't complex")
          
          try:
              client = anthropic.Anthropic()
              
              # Build prompt
              prompt = f'''You are helping with Refiloe, a WhatsApp AI assistant for South African personal trainers.
              
              Tech Stack: Python Flask, Supabase, Railway, WhatsApp Business API
              Context: South African (Rand currency, +27 phones)
              Model: You are {model_name}
              
              TASK: {clean_task}
              
              {context}
              
              Provide your response in this EXACT format:
              
              ## ANALYSIS
              [Brief analysis of what needs to be done]
              
              ## FILES TO CHANGE
              
              ### FILE: path/to/file.py
              ```python
              [Complete updated file content - the ENTIRE file]
              ```
              
              ### NEW FILE: path/to/new_file.py
              ```python
              [Complete new file content]
              ```
              
              ## MIGRATION: optional_migration_name.sql
              ```sql
              [SQL migration if needed]
              ```
              
              ## SUMMARY
              [Brief summary of changes made]
              
              IMPORTANT:
              - Provide COMPLETE file contents, not snippets
              - Fix any IndentationErrors or syntax errors found
              - Follow the rules in claude.md
              - Use exact file paths as shown in the structure
              '''
              
              print(f"\nü§ñ Calling {model_name}...")
              response = client.messages.create(
                  model=selected_model,
                  max_tokens=max_tokens,
                  messages=[{'role': 'user', 'content': prompt}]
              )
              
              response_text = response.content[0].text
              print(f"‚úì Received response: {len(response_text)} chars")
              
              # Save full response with metadata
              with open('claude_response.md', 'w', encoding='utf-8') as f:
                  f.write(f"<!-- Model: {model_name} -->\n")
                  f.write(f"<!-- Cost: ${estimated_cost:.4f} -->\n")
                  f.write(f"<!-- Tokens: ~{estimated_tokens:,.0f} -->\n\n")
                  f.write(response_text)
              
              # Parse and apply changes if requested
              changes_applied = []
              
              if auto_apply:
                  print("\nüìù Applying changes...")
                  
                  # Extract file changes
                  file_pattern = r'###\s*(NEW\s+)?FILE:\s*(.+?)\n```(?:python|sql|txt|md|yml|yaml|json)?\n(.*?)\n```'
                  migration_pattern = r'##\s*MIGRATION:\s*(.+?)\n```sql\n(.*?)\n```'
                  
                  # Apply file changes
                  for match in re.finditer(file_pattern, response_text, re.DOTALL):
                      is_new = match.group(1) is not None
                      file_path = match.group(2).strip()
                      content = match.group(3)
                      
                      try:
                          Path(file_path).parent.mkdir(parents=True, exist_ok=True)
                          with open(file_path, 'w', encoding='utf-8') as f:
                              f.write(content)
                          
                          action = "Created" if is_new else "Updated"
                          changes_applied.append(f"{action} {file_path}")
                          print(f"‚úì {action}: {file_path}")
                      except Exception as e:
                          print(f"‚úó Error writing {file_path}: {e}")
                  
                  # Apply migrations
                  for match in re.finditer(migration_pattern, response_text, re.DOTALL):
                      migration_name = match.group(1).strip()
                      if not migration_name.endswith('.sql'):
                          migration_name += '.sql'
                      
                      content = match.group(2)
                      
                      try:
                          Path('supabase/migrations').mkdir(parents=True, exist_ok=True)
                          timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                          migration_file = f"supabase/migrations/{timestamp}_{migration_name}"
                          
                          with open(migration_file, 'w', encoding='utf-8') as f:
                              f.write(content)
                          
                          changes_applied.append(f"Created migration {migration_file}")
                          print(f"‚úì Created migration: {migration_file}")
                      except Exception as e:
                          print(f"‚úó Error creating migration: {e}")
              
              # Prepare response summary
              if changes_applied:
                  summary = f"‚úÖ **Changes Applied Successfully:**\n"
                  for change in changes_applied:
                      summary += f"- {change}\n"
                  summary += f"\nüìù **Full Details:** See claude_response.md\n"
              else:
                  summary = "üìã **Analysis Complete** (no changes applied)\n"
                  if not auto_apply:
                      summary += "üí° Add `@apply` to automatically apply changes\n"
              
              # Add model and cost info
              summary += f"\nü§ñ **Model:** {model_name} ({model_reason})\n"
              summary += f"üí∞ **Cost:** ${estimated_cost:.4f}\n"
              summary += f"üìä **Tokens:** ~{estimated_tokens:,.0f}\n"
              
              # Save summary
              with open('summary.txt', 'w', encoding='utf-8') as f:
                  f.write(summary)
              
              # If auto-apply, commit changes
              if auto_apply and changes_applied:
                  try:
                      subprocess.run(['git', 'add', '.'], check=True)
                      
                      commit_msg = f"ü§ñ {model_name}: {clean_task[:50]}..."
                      subprocess.run(['git', 'commit', '-m', commit_msg], check=True)
                      
                      if create_pr:
                          timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                          branch_name = f"claude-{clean_task[:20].replace(' ', '-').lower()}-{timestamp}"
                          subprocess.run(['git', 'checkout', '-b', branch_name], check=True)
                          subprocess.run(['git', 'push', 'origin', branch_name], check=True)
                          
                          with open('pr_created.txt', 'w') as f:
                              f.write(branch_name)
                      else:
                          subprocess.run(['git', 'push'], check=True)
                      
                      print("‚úì Changes committed and pushed!")
                  except Exception as e:
                      print(f"‚úó Git error: {e}")
              
              # Save truncated response for comment
              if len(response_text) > 50000:
                  response_text = response_text[:50000] + "\n\n[... truncated - see claude_response.md]"
              
              with open('response.txt', 'w', encoding='utf-8') as f:
                  f.write(response_text)
                  
          except Exception as e:
              error_msg = str(e)
              print(f"‚úó Error: {error_msg}")
              
              with open('summary.txt', 'w', encoding='utf-8') as f:
                  f.write(f"‚ùå Error: {error_msg}")
              with open('response.txt', 'w', encoding='utf-8') as f:
                  f.write(f"Error: {error_msg}")
          PYTHON_SCRIPT
      
      - name: Post Response
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            let summary = '';
            let response = '';
            let prBranch = '';
            
            try {
              if (fs.existsSync('summary.txt')) {
                summary = fs.readFileSync('summary.txt', 'utf8');
              }
              if (fs.existsSync('response.txt')) {
                response = fs.readFileSync('response.txt', 'utf8');
              }
              if (fs.existsSync('pr_created.txt')) {
                prBranch = fs.readFileSync('pr_created.txt', 'utf8');
              }
            } catch (e) {
              console.log('Error reading files:', e);
            }
            
            let comment = `ü§ñ **Claude Response:**\n\n${summary}\n`;
            
            if (prBranch) {
              comment += `\nüîó **Pull Request:** Create a PR from branch \`${prBranch}\`\n`;
            }
            
            comment += `\n<details>\n<summary>üìÑ Full Analysis (click to expand)</summary>\n\n${response}\n</details>`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            })
