name: Claude Code Assistant
on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  claude:
    if: contains(github.event.comment.body, '@claude')
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install Dependencies
        run: |
          pip install anthropic
          pip install supabase
          pip install gitpython
      
      - name: Configure Git
        run: |
          git config --global user.name "Claude Assistant"
          git config --global user.email "claude@github-actions.bot"
      
      - name: Save comment to file
        run: |
          cat > comment.txt << 'ENDOFCOMMENT'
          ${{ github.event.comment.body }}
          ENDOFCOMMENT
      
      - name: Process with Claude and Apply Changes
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python - <<'PYTHON_SCRIPT'
          import anthropic
          import os
          import json
          import re
          from pathlib import Path
          import subprocess
          
          # Read the task
          with open('comment.txt', 'r') as f:
              comment = f.read()
          task = comment.replace('@claude', '').strip()
          
          print(f"Task: {task}")
          
          # Check for special commands
          auto_apply = '@apply' in task or '@commit' in task
          create_pr = '@pr' in task
          
          # Remove command keywords from task
          task = task.replace('@apply', '').replace('@commit', '').replace('@pr', '').strip()
          
          # Read project files
          project_files = {}
          
          # Get all Python files
          for py_file in Path('.').rglob('*.py'):
              if not str(py_file).startswith('.'):
                  try:
                      with open(py_file, 'r') as f:
                          content = f.read()
                          if len(content) > 10000:
                              content = content[:10000] + "\n\n[... truncated ...]"
                          project_files[str(py_file)] = content
                  except:
                      pass
          
          # Add other important files
          for file_path in ['requirements.txt', 'README.md', '.env.example']:
              if Path(file_path).exists():
                  try:
                      with open(file_path, 'r') as f:
                          project_files[file_path] = f.read()
                  except:
                      pass
          
          # Build context
          context = "PROJECT STRUCTURE:\n"
          for file_path in sorted(project_files.keys()):
              context += f"- {file_path}\n"
          
          context += "\n\nKEY FILES CONTENT:\n"
          # Include important files
          key_files = ['config.py', 'services/assessment.py', 'payment_manager.py']
          for file_path in key_files:
              if file_path in project_files:
                  context += f"\n=== {file_path} ===\n{project_files[file_path]}\n"
          
          try:
              client = anthropic.Anthropic()
              
              # Ask Claude for specific code changes
              prompt = f'''You are helping with Refiloe, a WhatsApp AI assistant for South African personal trainers.
              
              Tech Stack: Python Flask, Supabase, Railway, WhatsApp Business API
              Context: South African (Rand currency, +27 phones)
              
              TASK: {task}
              
              {context}
              
              Provide your response in this EXACT format:
              
              ## ANALYSIS
              [Brief analysis of what needs to be done]
              
              ## FILES TO CHANGE
              
              ### FILE: path/to/file.py
              ```python
              [Complete updated file content]
              ```
              
              ### FILE: path/to/another_file.py
              ```python
              [Complete updated file content]
              ```
              
              ### NEW FILE: path/to/new_file.py
              ```python
              [Complete new file content]
              ```
              
              ## MIGRATION: optional_migration_name.sql
              ```sql
              [SQL migration if needed]
              ```
              
              ## SUMMARY
              [Brief summary of changes made]
              
              IMPORTANT: 
              - Provide COMPLETE file contents, not snippets
              - Mark new files with "NEW FILE:"
              - Mark SQL migrations with "MIGRATION:"
              - Use exact file paths
              '''
              
              response = client.messages.create(
                  model='claude-opus-4-1-20250805',
                  max_tokens=8000,
                  messages=[{'role': 'user', 'content': prompt}]
              )
              
              response_text = response.content[0].text
              
              # Save full response
              with open('claude_response.md', 'w') as f:
                  f.write(response_text)
              
              # Parse and apply changes if requested
              changes_applied = []
              
              if auto_apply:
                  # Extract file changes
                  file_pattern = r'###\s*(NEW\s+)?FILE:\s*(.+?)\n```(?:python|sql|txt|md)?\n(.*?)\n```'
                  migration_pattern = r'##\s*MIGRATION:\s*(.+?)\n```sql\n(.*?)\n```'
                  
                  # Apply file changes
                  for match in re.finditer(file_pattern, response_text, re.DOTALL):
                      is_new = match.group(1) is not None
                      file_path = match.group(2).strip()
                      content = match.group(3)
                      
                      try:
                          # Create directories if needed
                          Path(file_path).parent.mkdir(parents=True, exist_ok=True)
                          
                          # Write file
                          with open(file_path, 'w') as f:
                              f.write(content)
                          
                          action = "Created" if is_new else "Updated"
                          changes_applied.append(f"{action} {file_path}")
                          print(f"{action}: {file_path}")
                      except Exception as e:
                          print(f"Error writing {file_path}: {e}")
                  
                  # Apply migrations
                  for match in re.finditer(migration_pattern, response_text, re.DOTALL):
                      migration_name = match.group(1).strip()
                      if not migration_name.endswith('.sql'):
                          migration_name += '.sql'
                      
                      content = match.group(2)
                      
                      try:
                          # Create migrations directory
                          Path('supabase/migrations').mkdir(parents=True, exist_ok=True)
                          
                          # Generate migration filename with timestamp
                          from datetime import datetime
                          timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                          migration_file = f"supabase/migrations/{timestamp}_{migration_name}"
                          
                          with open(migration_file, 'w') as f:
                              f.write(content)
                          
                          changes_applied.append(f"Created migration {migration_file}")
                          print(f"Created migration: {migration_file}")
                      except Exception as e:
                          print(f"Error creating migration: {e}")
              
              # Prepare response summary
              if changes_applied:
                  summary = f"‚úÖ **Changes Applied:**\n"
                  for change in changes_applied:
                      summary += f"- {change}\n"
                  summary += f"\nüìù **Full Details:** See claude_response.md\n"
              else:
                  summary = "üìã **Analysis Complete** (no changes applied)\n"
                  if '@apply' not in comment and '@commit' not in comment:
                      summary += "üí° Add `@apply` to your command to automatically apply changes\n"
              
              # Save summary for posting
              with open('summary.txt', 'w') as f:
                  f.write(summary)
              
              # If auto-apply, commit changes
              if auto_apply and changes_applied:
                  try:
                      subprocess.run(['git', 'add', '.'], check=True)
                      
                      commit_msg = f"ü§ñ Claude: {task[:50]}..."
                      subprocess.run(['git', 'commit', '-m', commit_msg], check=True)
                      
                      if create_pr:
                          # Create a new branch
                          branch_name = f"claude-{task[:20].replace(' ', '-').lower()}"
                          subprocess.run(['git', 'checkout', '-b', branch_name], check=True)
                          subprocess.run(['git', 'push', 'origin', branch_name], check=True)
                          
                          with open('pr_created.txt', 'w') as f:
                              f.write(branch_name)
                      else:
                          # Push to main
                          subprocess.run(['git', 'push'], check=True)
                      
                      print("Changes committed and pushed!")
                  except Exception as e:
                      print(f"Git error: {e}")
              
              # Also save a truncated response for the comment
              if len(response_text) > 50000:
                  response_text = response_text[:50000] + "\n\n[... truncated - see claude_response.md for full response]"
              
              with open('response.txt', 'w') as f:
                  f.write(response_text)
                  
          except Exception as e:
              print(f"Error: {e}")
              with open('summary.txt', 'w') as f:
                  f.write(f"‚ùå Error: {str(e)}")
              with open('response.txt', 'w') as f:
                  f.write(f"Error occurred: {str(e)}")
          PYTHON_SCRIPT
      
      - name: Post Response
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            let summary = '';
            let response = '';
            let prBranch = '';
            
            try {
              if (fs.existsSync('summary.txt')) {
                summary = fs.readFileSync('summary.txt', 'utf8');
              }
              if (fs.existsSync('response.txt')) {
                response = fs.readFileSync('response.txt', 'utf8');
              }
              if (fs.existsSync('pr_created.txt')) {
                prBranch = fs.readFileSync('pr_created.txt', 'utf8');
              }
            } catch (e) {
              console.log('Error reading files:', e);
            }
            
            let comment = `ü§ñ **Claude Response:**\n\n${summary}\n`;
            
            if (prBranch) {
              comment += `\nüîó **Pull Request:** Create a PR from branch \`${prBranch}\`\n`;
            }
            
            comment += `\n<details>\n<summary>üìÑ Full Analysis (click to expand)</summary>\n\n${response}\n</details>`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            })
