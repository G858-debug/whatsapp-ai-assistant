name: Claude AI Assistant

on:
  issue_comment:
    types: [created]

jobs:
  process-comment:
    # Only run on PR comments that mention @claude
    if: |
      github.event.issue.pull_request && 
      contains(github.event.comment.body, '@claude')
    
    runs-on: ubuntu-latest
    
    steps:
      - name: Get PR branch
        id: pr-branch
        uses: actions/github-script@v6
        with:
          result-encoding: string
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return pr.data.head.ref;
      
      - name: Checkout PR branch
        uses: actions/checkout@v3
        with:
          ref: ${{ steps.pr-branch.outputs.result }}
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install anthropic requests
      
      - name: Check for Railway logs requirement
        id: check-logs
        run: |
          # Check if the comment contains keywords that require Railway logs
          COMMENT="${{ github.event.comment.body }}"
          if echo "$COMMENT" | grep -iE "error|bug|crash|debug|logs|deployment|railway|not working|broken|failed|issue|problem|fix|investigate|trace|stack|500|502|503|timeout|exception"; then
            echo "fetch_logs=true" >> $GITHUB_OUTPUT
            echo "Railway logs will be fetched for this task"
          else
            echo "fetch_logs=false" >> $GITHUB_OUTPUT
            echo "No Railway logs needed for this task"
          fi
      
      - name: Fetch Railway logs (if needed)
        if: steps.check-logs.outputs.fetch_logs == 'true'
        id: railway-logs
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
          RAILWAY_PROJECT_ID: ${{ secrets.RAILWAY_PROJECT_ID }}
          RAILWAY_SERVICE_ID: ${{ secrets.RAILWAY_SERVICE_ID }}
        run: |
          python -c "
import sys
import os
import json

# Add project root to path
sys.path.insert(0, '.')

# Check if Railway credentials are configured
if not all([os.getenv('RAILWAY_API_TOKEN'), os.getenv('RAILWAY_PROJECT_ID'), os.getenv('RAILWAY_SERVICE_ID')]):
    print('Railway API credentials not configured - skipping log fetch')
    print('logs_context=')
    sys.exit(0)

try:
    from utils.railway_api import fetch_railway_logs, format_logs_for_context
    
    # Fetch logs
    result = fetch_railway_logs(limit=100)
    
    if result['success']:
        logs = result['logs']
        formatted = format_logs_for_context(logs, max_lines=50)
        
        # Save to file for next step (GitHub Actions has limits on output size)
        with open('railway_logs.txt', 'w') as f:
            f.write(formatted)
        
        print(f'Successfully fetched {len(logs)} Railway log entries')
        if result.get('deployment_status'):
            print(f'Deployment status: {result[\"deployment_status\"]}')
    else:
        print(f'Failed to fetch Railway logs: {result.get(\"error\", \"Unknown error\")}')
        with open('railway_logs.txt', 'w') as f:
            f.write('Railway logs unavailable')
            
except Exception as e:
    print(f'Error in Railway log fetch: {str(e)}')
    with open('railway_logs.txt', 'w') as f:
        f.write('Railway logs unavailable due to error')
"
      
      - name: Determine model based on comment
        id: model-select
        run: |
          COMMENT_LOWER=$(echo "${{ github.event.comment.body }}" | tr '[:upper:]' '[:lower:]')
          
          # Check for explicit model flags
          if [[ "$COMMENT_LOWER" == *"@opus"* ]]; then
            echo "model=opus" >> $GITHUB_OUTPUT
            echo "Using Opus 4.1 (explicitly requested)"
          elif [[ "$COMMENT_LOWER" == *"@sonnet"* ]]; then
            echo "model=sonnet" >> $GITHUB_OUTPUT
            echo "Using Sonnet 3.5 (explicitly requested)"
          # Check for @apply flag (suggests changes will be made)
          elif [[ "$COMMENT_LOWER" == *"@apply"* ]]; then
            # Check for complex indicators
            if [[ "$COMMENT_LOWER" == *"refactor"* ]] || 
               [[ "$COMMENT_LOWER" == *"redesign"* ]] || 
               [[ "$COMMENT_LOWER" == *"optimize"* ]] || 
               [[ "$COMMENT_LOWER" == *"multiple"* ]] || 
               [[ "$COMMENT_LOWER" == *"system"* ]] || 
               [[ "$COMMENT_LOWER" == *"architecture"* ]]; then
              echo "model=opus" >> $GITHUB_OUTPUT
              echo "Using Opus 4.1 (complex changes detected)"
            else
              echo "model=sonnet" >> $GITHUB_OUTPUT
              echo "Using Sonnet 3.5 (simple changes)"
            fi
          else
            # Analysis only - use Sonnet to save costs
            echo "model=sonnet" >> $GITHUB_OUTPUT
            echo "Using Sonnet 3.5 (analysis/read-only task)"
          fi
      
      - name: Process with Claude
        id: claude
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          # Required GitHub secrets for Railway API integration:
          # - RAILWAY_API_TOKEN: Your Railway API token (get from Railway dashboard > Account Settings > Tokens)
          # - RAILWAY_PROJECT_ID: Your Railway project ID (get from Railway project URL)
          # - RAILWAY_SERVICE_ID: Your Railway service ID (get from Railway service settings)
        run: |
          # Read Railway logs if they were fetched
          RAILWAY_LOGS=""
          if [ -f "railway_logs.txt" ]; then
            RAILWAY_LOGS=$(cat railway_logs.txt)
          fi
          
          python -c "
          import anthropic
          import os
          import sys
          import json
          from pathlib import Path
          
          # Get the comment
          comment = '''${{ github.event.comment.body }}'''
          
          # Determine which model to use
          model_choice = '${{ steps.model-select.outputs.model }}'
          
          if model_choice == 'opus':
              model = 'claude-3-opus-20240229'
              print('🤖 Using Claude Opus 4.1 for complex analysis')
          else:
              model = 'claude-3-5-sonnet-20241022'
              print('🤖 Using Claude Sonnet 3.5 for this task')
          
          # Read Railway logs if available
          railway_logs = ''
          if Path('railway_logs.txt').exists():
              with open('railway_logs.txt', 'r') as f:
                  railway_logs = f.read()
          
          # Read all project files
          def read_project_files():
              files_content = []
              skip_dirs = {'.git', '__pycache__', 'node_modules', '.github', 'logs', 'venv', '.env'}
              skip_extensions = {'.pyc', '.log', '.tmp', '.cache'}
              
              for root, dirs, files in os.walk('.'):
                  dirs[:] = [d for d in dirs if d not in skip_dirs]
                  for file in files:
                      if any(file.endswith(ext) for ext in skip_extensions):
                          continue
                      filepath = os.path.join(root, file)
                      try:
                          with open(filepath, 'r', encoding='utf-8') as f:
                              content = f.read()
                              files_content.append(f'\\n============\\nFILE: {filepath}\\n============\\n{content}')
                      except:
                          continue
              return '\\n'.join(files_content)
          
          # Build the context
          project_context = read_project_files()
          
          # Include Railway logs in context if available
          if railway_logs:
              project_context = railway_logs + '\\n\\n' + project_context
          
          # Create the prompt
          prompt = f'''You are a senior software engineer helping with Refiloe, a WhatsApp AI assistant for South African personal trainers.
          
          Tech Stack: Python Flask, Supabase, Railway, WhatsApp Business API
          Context: South African (Rand currency, +27 phones)
          Model: You are {model}
          
          TASK: {comment}
          
          === PROJECT STRUCTURE ===
          {chr(10).join([str(p) for p in Path('.').rglob('*') if p.is_file() and '.git' not in str(p)][:100])}
          
          === COMPLETE CODEBASE ===
          {project_context}
          
          Provide your response in this EXACT format:
          
          ## ANALYSIS
          [Brief analysis of what needs to be done]
          
          ## FILES TO CHANGE
          
          ### FILE: path/to/file.py
          \`\`\`python
          [Complete updated file content - the ENTIRE file]
          \`\`\`
          
          ### NEW FILE: path/to/new_file.py
          \`\`\`python
          [Complete new file content]
          \`\`\`
          
          ## MIGRATION: optional_migration_name.sql
          \`\`\`sql
          [SQL migration if needed]
          \`\`\`
          
          ## SUMMARY
          [Brief summary of changes made]
          
          IMPORTANT:
          - Provide COMPLETE file contents, not snippets
          - Fix any IndentationErrors or syntax errors found
          - Follow the rules in claude.md
          - Use exact file paths as shown in the structure
          '''
          
          # Call Claude
          client = anthropic.Anthropic(api_key=os.environ['ANTHROPIC_API_KEY'])
          
          message = client.messages.create(
              model=model,
              max_tokens=8000,
              temperature=0.2,
              messages=[
                  {
                      'role': 'user',
                      'content': prompt
                  }
              ]
          )
          
          response = message.content[0].text
          
          # Save response
          with open('claude_response.md', 'w') as f:
              f.write(response)
          
          # Extract changes to apply
          import re
          
          apply_changes = '@apply' in comment.lower()
          
          if apply_changes:
              # Parse files to change
              file_blocks = re.findall(r'### (?:FILE|NEW FILE): (.*?)\\n\`\`\`(?:python|javascript|sql|json|yaml|txt|md)\\n(.*?)\`\`\`', response, re.DOTALL)
              
              changes_made = []
              for filepath, content in file_blocks:
                  filepath = filepath.strip()
                  # Create directories if needed
                  os.makedirs(os.path.dirname(filepath) if os.path.dirname(filepath) else '.', exist_ok=True)
                  
                  # Write file
                  with open(filepath, 'w') as f:
                      f.write(content)
                  changes_made.append(filepath)
                  print(f'✅ Updated: {filepath}')
              
              # Handle SQL migrations
              migration_blocks = re.findall(r'## MIGRATION: (.*?)\\n\`\`\`sql\\n(.*?)\`\`\`', response, re.DOTALL)
              for migration_name, sql_content in migration_blocks:
                  migration_name = migration_name.strip()
                  if migration_name and migration_name != 'optional_migration_name.sql':
                      migration_path = f'supabase/migrations/{migration_name}'
                      os.makedirs(os.path.dirname(migration_path), exist_ok=True)
                      with open(migration_path, 'w') as f:
                          f.write(sql_content)
                      changes_made.append(migration_path)
                      print(f'✅ Created migration: {migration_path}')
              
              # Save summary
              with open('summary.txt', 'w') as f:
                  if changes_made:
                      f.write(f'✅ **Changes Applied Successfully:**\\n')
                      for file in changes_made:
                          f.write(f'- Updated {file}\\n')
                  else:
                      f.write('ℹ️ **No file changes detected in response**\\n')
                  f.write(f'\\n📝 **Full Details:** See claude_response.md')
                  f.write(f'\\n🤖 **Model Used:** Claude {\"Opus 4.1\" if model_choice == \"opus\" else \"Sonnet 3.5\"}')
          else:
              with open('summary.txt', 'w') as f:
                  f.write('📋 **Analysis Complete**\\n')
                  f.write('No changes applied (use @apply to make changes)\\n')
                  f.write(f'\\n📝 **Full Details:** See claude_response.md')
                  f.write(f'\\n🤖 **Model Used:** Claude {\"Opus 4.1\" if model_choice == \"opus\" else \"Sonnet 3.5\"}')
          
          print('✅ Claude processing complete!')
          "
      
      - name: Check for changes
        id: check-changes
        run: |
          if git diff --quiet && git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff --name-only
          fi
      
      - name: Commit and push changes
        if: steps.check-changes.outputs.has_changes == 'true' && contains(github.event.comment.body, '@apply')
        run: |
          git config --global user.name "Claude AI Assistant"
          git config --global user.email "claude@ai.assistant"
          
          # Stage all changes
          git add -A
          
          # Create commit message
          COMMIT_MSG="Apply Claude AI suggestions from PR comment"
          if [ -f summary.txt ]; then
            COMMIT_MSG="$COMMIT_MSG

$(cat summary.txt)"
          fi
          
          git commit -m "$COMMIT_MSG"
          
          # Push to the PR branch
          git push origin HEAD
          
          echo "✅ Changes committed and pushed!"
      
      - name: Post response comment
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            let comment = '## 🤖 Claude AI Response\n\n';
            
            // Add summary
            if (fs.existsSync('summary.txt')) {
              const summary = fs.readFileSync('summary.txt', 'utf8');
              comment += summary + '\n\n';
            }
            
            // Add response preview (first 500 chars)
            if (fs.existsSync('claude_response.md')) {
              const response = fs.readFileSync('claude_response.md', 'utf8');
              if (response.length > 500) {
                comment += '<details>\n<summary>📄 Full Response (click to expand)</summary>\n\n';
                comment += '```markdown\n' + response + '\n```\n';
                comment += '</details>\n';
              } else {
                comment += '### Response:\n' + response + '\n';
              }
            }
            
            // Add Railway logs status if they were fetched
            if ('${{ steps.check-logs.outputs.fetch_logs }}' === 'true') {
              comment += '\n\n📊 **Railway Logs**: ';
              if (fs.existsSync('railway_logs.txt')) {
                const logs = fs.readFileSync('railway_logs.txt', 'utf8');
                if (logs && logs !== 'Railway logs unavailable') {
                  comment += 'Included in analysis';
                } else {
                  comment += 'Not available';
                }
              } else {
                comment += 'Not fetched';
              }
            }
            
            // Add changes status
            if ('${{ steps.check-changes.outputs.has_changes }}' === 'true') {
              comment += '\n\n✅ **Changes have been applied to the PR branch**';
            } else if ('${{ github.event.comment.body }}'.includes('@apply')) {
              comment += '\n\n⚠️ **No changes were needed**';
            }
            
            // Post the comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
