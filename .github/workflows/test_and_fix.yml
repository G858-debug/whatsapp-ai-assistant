# .github/workflows/test_and_fix.yml
name: Test Conversations & Auto-Fix

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:  # Allow manual trigger
    inputs:
      fix_mode:
        description: 'Auto-fix mode'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - manual
          - report-only

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  test-conversations:
    runs-on: ubuntu-latest
    
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
      SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      WHATSAPP_TOKEN: ${{ secrets.WHATSAPP_TOKEN }}
      WHATSAPP_PHONE_ID: ${{ secrets.WHATSAPP_PHONE_ID }}
      TIMEZONE: 'Africa/Johannesburg'
      TEST_PHONE: '27731863036'
      
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0
        token: ${{ secrets.PAT || secrets.GITHUB_TOKEN }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-html pytest-json-report colorama
    
    - name: Debug - Check environment
      run: |
        echo "=== Checking environment ==="
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la
        echo ""
        echo "Python path:"
        python -c "import sys; print('\n'.join(sys.path))"
        echo ""
        echo "Installed packages:"
        pip list | head -20
    
    - name: Setup test environment
      run: |
        echo "Setting up test environment..."
        # Check if setup file exists
        if [ -f "tests/setup_test_env.py" ]; then
          python tests/setup_test_env.py
        else
          echo "Setup file not found, skipping..."
        fi
    
    - name: Run debug test first
      continue-on-error: true
      run: |
        echo "Running debug test to identify issues..."
        python -c "import sys, os; print('Python:', sys.version); print('Current dir:', os.getcwd()); print('Services exists:', os.path.exists('services')); print('Tests exists:', os.path.exists('tests'))"
        
        # If debug test file exists, run it too
        if [ -f "tests/test_debug.py" ]; then
          echo "Running test_debug.py..."
          python tests/test_debug.py || true
        fi
    
    - name: Run conversation flow tests
      id: run-tests
      continue-on-error: true
      run: |
        echo "Running comprehensive real-world tests..."
        
        # IMPORTANT: Clean up any pre-existing test artifacts that might interfere
        rm -f test-results.json generated_fixes.json fix_summary.json 2>/dev/null || true
        
        # Create default results in case tests fail to run
        echo '{"summary": {"total": 0, "passed": 0, "failed": 0}, "tests": []}' > test-results.json
        echo "<html><body>Tests not run</body></html>" > test-report.html
        
        # Remove any test files that might interfere with fix generation
        rm -f tests/test_pr_generation.py 2>/dev/null || true
        rm -f tests/test_fix_generation.py 2>/dev/null || true
        
        # First, try to run the comprehensive real-world tests
        if [ -f "tests/test_refiloe_real_world.py" ]; then
          echo "Running real-world comprehensive tests..."
          python -m pytest tests/test_refiloe_real_world.py \
            --ignore=tests/test_pr_generation.py \
            --ignore=tests/test_fix_generation.py \
            --html=test-report.html \
            --self-contained-html \
            --json-report \
            --json-report-file=test-results.json \
            -v \
            --tb=short \
            --capture=no 2>&1 | tee test-output.log
          TEST_EXIT_CODE=${PIPESTATUS[0]}
        else
          echo "Real-world tests not found, running basic tests..."
          python -m pytest tests/ \
            --ignore=tests/test_railway_api.py \
            --ignore=tests/test_calendar_service.py \
            --ignore=tests/test_pr_generation.py \
            --ignore=tests/test_fix_generation.py \
            --html=test-report.html \
            --self-contained-html \
            --json-report \
            --json-report-file=test-results.json \
            -v \
            --tb=short \
            --capture=no 2>&1 | tee test-output.log
          TEST_EXIT_CODE=${PIPESTATUS[0]}
        fi
        
        # CRITICAL FIX: Capture the actual pytest exit code
        echo "Pytest exit code: $TEST_EXIT_CODE"
        
        if [ $TEST_EXIT_CODE -eq 0 ]; then
          echo "✅ All tests passed!"
          echo "test_status=success" >> $GITHUB_ENV
        else
          echo "❌ Some tests failed (exit code: $TEST_EXIT_CODE)"
          echo "test_status=failure" >> $GITHUB_ENV
          
          # Show failed tests
          echo "=== Failed Tests ==="
          grep -E "FAILED|ERROR" test-output.log | head -20 || true
          
          # Check for specific issues
          if grep -q "currency\|pricing\|R450" test-output.log; then
            echo "💰 Currency parsing issues detected"
          fi
          if grep -q "natural\|ai\|invalid command" test-output.log; then
            echo "🤖 Natural language processing issues detected"
          fi
          if grep -q "registration\|step 7" test-output.log; then
            echo "📝 Registration flow issues detected"
          fi
          
          # Always show test summary
          if [ -f "test-results.json" ]; then
            echo "=== Test Summary ==="
            python -c "import json; d=json.load(open('test-results.json')); s=d.get('summary',{}); print(f\"Total: {s.get('total',0)}, Passed: {s.get('passed',0)}, Failed: {s.get('failed',0)}\")" || true
          fi
        fi

    - name: Check for test loop
      if: env.test_status == 'failure'
      continue-on-error: false
      run: |
        echo "=== Checking for test failure loop ==="
        
        # Create the detect_test_loop.py script if it doesn't exist
        mkdir -p .github/scripts
        
        cat > .github/scripts/detect_test_loop.py << 'EOLOOP'
        #!/usr/bin/env python3
        import json
        import hashlib
        import sys
        from pathlib import Path
        
        def get_failure_signature():
            try:
                with open('test-results.json', 'r') as f:
                    data = json.load(f)
                
                failed_tests = sorted([
                    t['nodeid'] for t in data.get('tests', [])
                    if t.get('outcome') == 'failed'
                ])
                
                if not failed_tests:
                    return None, []
                
                signature = hashlib.md5(''.join(failed_tests).encode()).hexdigest()[:10]
                return signature, failed_tests
            except Exception as e:
                print(f"Error: {e}")
                return None, []
        
        def main():
            current_sig, failed_tests = get_failure_signature()
            
            if not current_sig:
                print("No failures found")
                sys.exit(0)
            
            print(f"Current signature: {current_sig}")
            print(f"Failed tests: {len(failed_tests)}")
            
            history_dir = Path('.test-history')
            history_dir.mkdir(exist_ok=True)
            
            sig_file = history_dir / 'last-signature.txt'
            loop_count_file = history_dir / 'loop-count.txt'
            
            loop_count = 0
            if sig_file.exists():
                last_sig = sig_file.read_text().strip()
                if last_sig == current_sig:
                    if loop_count_file.exists():
                        loop_count = int(loop_count_file.read_text().strip())
                    loop_count += 1
                    loop_count_file.write_text(str(loop_count))
                    
                    if loop_count >= 3:
                        print(f"🔄 LOOP DETECTED! Same failures recurring (signature: {current_sig}...)")
                        print("The same tests are failing with identical errors.")
                        print("Manual intervention required to fix the root cause.")
                        print("Repeatedly failing tests:")
                        for test in failed_tests[:10]:
                            print(f" - {test}")
                        sys.exit(1)
                    else:
                        print(f"Attempt {loop_count} of 2")
                        sys.exit(0)
                else:
                    loop_count_file.write_text('0')
            else:
                loop_count_file.write_text('0')
            
            sig_file.write_text(current_sig)
            sys.exit(0)
        
        if __name__ == "__main__":
            main()
        EOLOOP
        
        # Make it executable and run it
        chmod +x .github/scripts/detect_test_loop.py
        
        # Run loop detection
        if python .github/scripts/detect_test_loop.py; then
          echo "No loop detected, proceeding with auto-fix..."
        else
          echo "❌ TEST LOOP DETECTED!"
          echo "The auto-fix system is stuck in a loop."
          echo "Manual intervention required."
          echo "fixes_generated=false" >> $GITHUB_ENV
          exit 1
        fi
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: |
          test-report.html
          test-results.json
          test-output.log
    
    - name: Display test results
      if: always()
      run: |
        echo "=== Displaying Test Results ==="
        
        # Show JSON results if available
        if [ -f "test-results.json" ]; then
          echo "Test Results JSON:"
          cat test-results.json | python -m json.tool | head -100 || true
          
          # Extract and show failed tests
          echo ""
          echo "=== Failed Tests ==="
          python -c "import json; d=json.load(open('test-results.json')); [print(f\"❌ {t.get('nodeid','Unknown')}\") for t in d.get('tests',[]) if t.get('outcome')=='failed']" || true
        else
          echo "No test results JSON found"
        fi
    
    - name: Analyze failures and generate fixes
      id: analyze-fixes
      if: always() && env.test_status == 'failure'
      run: |
        echo "=== Starting fix analysis ==="
        echo "Step triggered with test_status: ${{ env.test_status }}"
        
        # Remove any old generated files first
        rm -f generated_fixes.json fix_summary.json fix-generator.log || true
        
        # Check current directory and files
        pwd
        ls -la tests/auto_fix_generator.py || echo "Generator file not found!"
        
        # Show test results exist
        if [ -f "test-results.json" ]; then
          echo "test-results.json exists, size: $(stat -c%s test-results.json 2>/dev/null || stat -f%z test-results.json 2>/dev/null || echo 'unknown') bytes"
          
          # Show first few lines of test results for debugging
          echo "=== First 500 chars of test-results.json ==="
          head -c 500 test-results.json || true
          echo ""
          
          # Count tests
          TOTAL_TESTS=$(python -c "import json; d=json.load(open('test-results.json')); print(len(d.get('tests',[])))" 2>/dev/null || echo "0")
          FAILED_COUNT=$(python -c "import json; d=json.load(open('test-results.json')); print(len([t for t in d.get('tests',[]) if t.get('outcome')=='failed']))" 2>/dev/null || echo "0")
          
          echo "Total tests in file: $TOTAL_TESTS"
          echo "Failed tests in file: $FAILED_COUNT"
          
          # Show some failed test names
          echo "=== Failed test names ==="
          python -c "import json; d=json.load(open('test-results.json')); [print(t.get('nodeid','Unknown')[:80]) for t in d.get('tests',[])[:5] if t.get('outcome')=='failed']" 2>/dev/null || echo "Could not extract test names"
          
          if [ "$FAILED_COUNT" -gt "0" ]; then
            echo "Running fix generator on $FAILED_COUNT failures..."
            
            # Ensure the generator script exists
            if [ ! -f "tests/auto_fix_generator.py" ]; then
              echo "ERROR: auto_fix_generator.py not found!"
              echo "fixes_generated=false" >> $GITHUB_ENV
              exit 0
            fi
            
            # Run with explicit python path
            echo "=== Running generator ==="
            python3 tests/auto_fix_generator.py 2>&1 | tee fix-generator.log
            GENERATOR_EXIT=${PIPESTATUS[0]}
            
            echo "Generator exit code: $GENERATOR_EXIT"
            
            # Show generator output
            echo "=== Generator Output ==="
            cat fix-generator.log || true
            
            # Check results
            if [ -f "generated_fixes.json" ]; then
              echo "✅ generated_fixes.json created"
              echo "=== Generated Fixes ==="
              cat generated_fixes.json | python -m json.tool | head -50 || cat generated_fixes.json | head -50
              
              # Count fixes
              FIX_COUNT=$(python -c "import json; print(len(json.load(open('generated_fixes.json'))))" 2>/dev/null || echo "0")
              echo "Generated $FIX_COUNT fixes"
              
              if [ "$FIX_COUNT" -gt "0" ]; then
                echo "fixes_generated=true" >> $GITHUB_ENV
                echo "✅ Setting fixes_generated=true"
              else
                echo "⚠️ Fix file exists but contains no fixes"
                echo "fixes_generated=false" >> $GITHUB_ENV
              fi
            else
              echo "❌ No generated_fixes.json file created"
              echo "fixes_generated=false" >> $GITHUB_ENV
            fi
          else
            echo "No failures found in test results"
            echo "fixes_generated=false" >> $GITHUB_ENV
          fi
        else
          echo "❌ test-results.json not found!"
          echo "fixes_generated=false" >> $GITHUB_ENV
        fi
    
    - name: Apply auto-fixes and create PR
      if: env.fixes_generated == 'true' && github.event.inputs.fix_mode != 'report-only'
      env:
        GH_TOKEN: ${{ secrets.PAT || secrets.GITHUB_TOKEN }}
      run: |
        echo "=== Applying fixes and creating PR ==="
        
        # Configure git
        git config --global user.name 'Refiloe Auto-Fix Bot'
        git config --global user.email 'bot@refiloe.ai'
        
        # Create fix branch
        BRANCH_NAME="auto-fix-$(date +%Y%m%d-%H%M%S)"
        git checkout -b $BRANCH_NAME
        
        # Show what fixes will be applied
        echo "=== Fixes to Apply ==="
        cat generated_fixes.json | python -m json.tool | head -30 || true
        
        # Apply fixes
        echo "=== Applying Fixes ==="
        if python tests/apply_fixes.py 2>&1 | tee apply-fixes.log; then
          echo "✅ Fixes applied successfully"
        else
          echo "⚠️ Some fixes may have failed to apply"
          cat apply-fixes.log || true
        fi
        
        # Show what changed
        echo "=== Git Status ==="
        git status
        
        echo "=== Git Diff ==="
        git diff | head -100 || true
        
        # Commit changes if any
        if [[ -n $(git status -s) ]]; then
          echo "Files were modified, creating commit..."
          git add -A
          git commit -m "🔧 Auto-fix: Resolve conversation flow issues

          Automated fixes for test failures:
          $(python tests/get_fix_summary.py 2>/dev/null || echo 'Various test fixes')"
          
          # Push branch
          echo "Pushing branch $BRANCH_NAME..."
          git remote set-url origin https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git
          git push origin $BRANCH_NAME
          
          # Create PR using GitHub CLI
          echo "Creating Pull Request..."
          gh pr create \
            --title "🔧 Auto-Fix: Conversation Flow Issues" \
            --body "$(python tests/generate_pr_description.py 2>/dev/null || echo 'Automated fixes for test failures')" \
            --base main \
            --head $BRANCH_NAME \
            --label "auto-fix" \
            --assignee ${{ github.actor }} || echo "PR creation failed - you may need to create it manually"
        else
          echo "No files were changed - no PR needed"
          echo "=== Debug: Check why no changes ==="
          ls -la services/registration/trainer_registration.py utils/validators.py 2>/dev/null || true
        fi
    
    - name: Post test summary to PR
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          
          // Check if test-results.json exists
          if (!fs.existsSync('test-results.json')) {
            console.log('No test results file found');
            return;
          }
          
          const results = JSON.parse(fs.readFileSync('test-results.json', 'utf8'));
          
          const passed = results.tests.filter(t => t.outcome === 'passed').length;
          const failed = results.tests.filter(t => t.outcome === 'failed').length;
          const total = results.tests.length;
          
          const emoji = failed === 0 ? '✅' : '❌';
          const status = failed === 0 ? 'All tests passed!' : `${failed} test(s) failed`;
          
          const comment = `## ${emoji} Conversation Flow Test Results
          
          **Status:** ${status}
          **Passed:** ${passed}/${total}
          
          ${failed > 0 ? '### Failed Tests:\n' + results.tests
            .filter(t => t.outcome === 'failed')
            .map(t => `- ❌ ${t.nodeid}`)
            .slice(0, 10)
            .join('\n') : ''}
          
          [View detailed report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
    
    - name: Cleanup test data
      if: always()
      run: |
        echo "Cleaning up test data from Supabase..."
        python tests/cleanup_test_data.py || echo "Cleanup script not found or failed"
    
    - name: Celebrate success
      if: success() && env.test_status == 'success'
      run: |
        echo "🎉🎉🎉 ALL TESTS PASSED! 🎉🎉🎉"
        echo "================================"
        echo "✅ Test suite is working correctly"
        echo "✅ All conversation flows passed"
        echo "✅ No fixes needed"
        echo "================================"
    
    - name: Send notification
      if: failure() && github.ref == 'refs/heads/main'
      run: |
        echo "Tests failed on main branch - would send notification here"
        # Could integrate with Slack, email, or WhatsApp notification
