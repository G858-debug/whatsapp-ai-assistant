@claude @apply

Here is the complete content of services/refiloe.py:
from typing import Dict, Optional, List, Tuple
from datetime import datetime, timedelta
import json
import re
from anthropic import Anthropic
from config import Config
from utils.logger import log_error, log_info
from services.whatsapp import WhatsAppService
from services.scheduler import SchedulerService
from services.workout import WorkoutService
from services.assessment import EnhancedAssessmentService
from services.habits import HabitTrackingService
from services.analytics import AnalyticsService
from services.subscription_manager import SubscriptionManager
from services.ai_intent_handler import AIIntentHandler
from payment_manager import PaymentManager


class RefiloeService:
    """Main service orchestrator for Refiloe AI assistant"""
    
    def __init__(self, supabase_client):
        """Initialize Refiloe with all required services"""
        self.db = supabase_client
        self.config = Config
        
        # Initialize core services
        self.whatsapp = WhatsAppService(supabase_client)
        self.scheduler = SchedulerService(supabase_client)
        self.workout = WorkoutService(supabase_client)
        self.assessment = EnhancedAssessmentService(supabase_client)
        self.habits = HabitTrackingService(supabase_client)
        self.analytics = AnalyticsService(supabase_client)
        self.subscription = SubscriptionManager(supabase_client)
        self.payment = PaymentManager(supabase_client)
        self.ai_handler = AIIntentHandler(supabase_client)
        
        # Initialize Anthropic client
        self.anthropic = Anthropic(api_key=Config.ANTHROPIC_API_KEY)
        
        log_info("RefiloeService initialized successfully")
    
    def process_message(self, message_data: Dict) -> Dict:
        """Process incoming WhatsApp message"""
        try:
            # Extract message details
            from_number = message_data.get('from')
            message_type = message_data.get('type', 'text')
            
            # Get or create user context
            user_context = self._get_user_context(from_number)
            
            # Route based on message type
            if message_type == 'text':
                response = self._handle_text_message(message_data, user_context)
            elif message_type == 'audio':
                response = self._handle_voice_message(message_data, user_context)
            elif message_type == 'image':
                response = self._handle_image_message(message_data, user_context)
            elif message_type == 'interactive':
                response = self._handle_interactive_message(message_data, user_context)
            else:
                response = {
                    'success': False,
                    'message': "I don't understand that type of message yet. Please send text or voice notes."
                }
            
            # Log interaction
            self._log_interaction(from_number, message_data, response)
            
            return response
            
        except Exception as e:
            log_error(f"Error processing message: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I encountered an error. Please try again."
            }
    
    def _handle_text_message(self, message_data: Dict, user_context: Dict) -> Dict:
        """Handle text message"""
        try:
            text = message_data.get('text', {}).get('body', '')
            from_number = message_data.get('from')
            
            # Check for commands
            if text.lower().startswith('/'):
                return self._handle_command(text, from_number, user_context)
            
            # Use AI to understand intent
            intent_result = self.ai_handler.process_message(text, user_context)
            
            # Route based on intent
            if intent_result['intent'] == 'booking':
                return self._handle_booking_intent(intent_result, from_number, user_context)
            elif intent_result['intent'] == 'payment':
                return self._handle_payment_intent(intent_result, from_number, user_context)
            elif intent_result['intent'] == 'workout':
                return self._handle_workout_intent(intent_result, from_number, user_context)
            elif intent_result['intent'] == 'assessment':
                return self._handle_assessment_intent(intent_result, from_number, user_context)
            elif intent_result['intent'] == 'habit':
                return self._handle_habit_intent(intent_result, from_number, user_context)
            elif intent_result['intent'] == 'general':
                return self._handle_general_query(text, user_context)
            else:
                return {
                    'success': True,
                    'message': intent_result.get('response', "I'm not sure how to help with that. Try asking about bookings, workouts, or assessments.")
                }
                
        except Exception as e:
            log_error(f"Error handling text message: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process your message. Please try again."
            }
    
    def _handle_voice_message(self, message_data: Dict, user_context: Dict) -> Dict:
        """Handle voice message"""
        try:
            # For now, return a placeholder response
            # TODO: Implement voice transcription
            return {
                'success': True,
                'message': "ðŸŽ¤ I received your voice message! Voice processing is coming soon. For now, please send text messages."
            }
        except Exception as e:
            log_error(f"Error handling voice message: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process your voice message."
            }
    
    def _handle_image_message(self, message_data: Dict, user_context: Dict) -> Dict:
        """Handle image message"""
        try:
            # Check if this is for an assessment
            if user_context.get('expecting_assessment_photo'):
                return self._process_assessment_photo(message_data, user_context)
            
            return {
                'success': True,
                'message': "ðŸ“¸ Thanks for the image! To submit assessment photos, please start an assessment first."
            }
        except Exception as e:
            log_error(f"Error handling image: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process your image."
            }
    
    def _handle_interactive_message(self, message_data: Dict, user_context: Dict) -> Dict:
        """Handle interactive button/list responses"""
        try:
            interactive = message_data.get('interactive', {})
            response_type = interactive.get('type')
            
            if response_type == 'button_reply':
                button_id = interactive.get('button_reply', {}).get('id')
                return self._handle_button_click(button_id, user_context)
            elif response_type == 'list_reply':
                list_id = interactive.get('list_reply', {}).get('id')
                return self._handle_list_selection(list_id, user_context)
            
            return {
                'success': False,
                'message': "I couldn't understand your selection."
            }
            
        except Exception as e:
            log_error(f"Error handling interactive message: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process your selection."
            }
    
    def _handle_command(self, command: str, from_number: str, user_context: Dict) -> Dict:
        """Handle slash commands"""
        try:
            cmd = command.lower().strip()
            
            if cmd == '/help':
                return self._get_help_message(user_context)
            elif cmd == '/book':
                return self._start_booking_flow(from_number, user_context)
            elif cmd == '/cancel':
                return self._cancel_current_action(user_context)
            elif cmd == '/status':
                return self._get_user_status(from_number, user_context)
            elif cmd == '/workout':
                return self._start_workout_flow(from_number, user_context)
            elif cmd == '/assess':
                return self._start_assessment_flow(from_number, user_context)
            elif cmd == '/pay':
                return self._check_payment_status(from_number, user_context)
            else:
                return {
                    'success': True,
                    'message': f"Unknown command: {cmd}\n\nAvailable commands:\n/help - Show help\n/book - Book a session\n/workout - Get workout\n/assess - Start assessment\n/status - Check status\n/pay - Payment info"
                }
                
        except Exception as e:
            log_error(f"Error handling command: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process that command."
            }
    
    def _handle_booking_intent(self, intent_result: Dict, from_number: str, user_context: Dict) -> Dict:
        """Handle booking-related intents"""
        try:
            entities = intent_result.get('entities', {})
            
            # Check if we have enough info to book
            if entities.get('date') and entities.get('time'):
                return self.scheduler.book_session(
                    client_phone=from_number,
                    date=entities['date'],
                    time=entities['time'],
                    trainer_id=user_context.get('trainer_id')
                )
            else:
                # Start booking flow
                return self._start_booking_flow(from_number, user_context)
                
        except Exception as e:
            log_error(f"Error handling booking intent: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process your booking request."
            }
    
    def _handle_payment_intent(self, intent_result: Dict, from_number: str, user_context: Dict) -> Dict:
        """Handle payment-related intents"""
        try:
            # Check outstanding payments
            outstanding = self.payment.check_payment_status(from_number)
            
            if outstanding.get('has_outstanding'):
                return {
                    'success': True,
                    'message': f"ðŸ’° You have an outstanding balance of R{outstanding['amount']:.2f}\n\nTo pay: {outstanding.get('payment_link', 'Contact your trainer for payment details')}"
                }
            else:
                return {
                    'success': True,
                    'message': "âœ… You're all paid up! No outstanding payments."
                }
                
        except Exception as e:
            log_error(f"Error handling payment intent: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't check your payment status."
            }
    
    def _handle_workout_intent(self, intent_result: Dict, from_number: str, user_context: Dict) -> Dict:
        """Handle workout-related intents"""
        try:
            entities = intent_result.get('entities', {})
            muscle_group = entities.get('muscle_group', 'full body')
            
            workout = self.workout.generate_workout(
                client_id=user_context.get('client_id'),
                muscle_group=muscle_group
            )
            
            if workout.get('success'):
                return {
                    'success': True,
                    'message': workout['workout_text'],
                    'media_url': workout.get('gif_url')
                }
            else:
                return {
                    'success': False,
                    'message': "Sorry, I couldn't generate a workout right now."
                }
                
        except Exception as e:
            log_error(f"Error handling workout intent: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process your workout request."
            }
    
    def _handle_assessment_intent(self, intent_result: Dict, from_number: str, user_context: Dict) -> Dict:
        """Handle assessment-related intents"""
        try:
            # Check for pending assessment
            assessments = self.assessment.get_client_assessments(
                user_context.get('client_id')
            )
            
            pending = [a for a in assessments if a['status'] == 'pending']
            
            if pending:
                return {
                    'success': True,
                    'message': f"ðŸ“‹ You have a pending assessment!\n\nDue: {pending[0]['due_date']}\n\nReply 'start assessment' to begin."
                }
            else:
                return {
                    'success': True,
                    'message': "No pending assessments. Your trainer will schedule one when needed."
                }
                
        except Exception as e:
            log_error(f"Error handling assessment intent: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't check your assessments."
            }
    
    def _handle_habit_intent(self, intent_result: Dict, from_number: str, user_context: Dict) -> Dict:
        """Handle habit tracking intents"""
        try:
            entities = intent_result.get('entities', {})
            habit_type = entities.get('habit_type')
            value = entities.get('value')
            
            if habit_type and value:
                result = self.habits.log_habit(
                    client_id=user_context.get('client_id'),
                    habit_type=habit_type,
                    value=value
                )
                
                if result.get('success'):
                    return {
                        'success': True,
                        'message': f"âœ… Logged: {habit_type} - {value}\n\nGreat job staying consistent!"
                    }
            
            return {
                'success': True,
                'message': "ðŸ“Š Track your habits! Just tell me:\nâ€¢ Water intake (e.g., '2 liters water')\nâ€¢ Sleep (e.g., '8 hours sleep')\nâ€¢ Steps (e.g., '10000 steps')\nâ€¢ Workouts (e.g., 'completed workout')"
            }
            
        except Exception as e:
            log_error(f"Error handling habit intent: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't log that habit."
            }
    
    def _handle_general_query(self, text: str, user_context: Dict) -> Dict:
        """Handle general queries with AI"""
        try:
            # Use Claude for general fitness advice
            response = self.anthropic.messages.create(
                model=Config.AI_MODEL,
                max_tokens=500,
                messages=[
                    {
                        "role": "system",
                        "content": "You are Refiloe, a friendly South African fitness AI assistant. Provide helpful, encouraging fitness and health advice. Keep responses concise and practical."
                    },
                    {
                        "role": "user",
                        "content": text
                    }
                ]
            )
            
            return {
                'success': True,
                'message': response.content[0].text
            }
            
        except Exception as e:
            log_error(f"Error with AI response: {str(e)}")
            return {
                'success': True,
                'message': "I'm here to help with bookings, workouts, assessments, and tracking your fitness journey. What would you like to do?"
            }
    
    def _get_user_context(self, phone_number: str) -> Dict:
        """Get or create user context"""
        try:
            # Try to get existing client
            result = self.db.table('clients').select('*').eq(
                'phone_number', phone_number
            ).single().execute()
            
            if result.data:
                return {
                    'client_id': result.data['id'],
                    'trainer_id': result.data.get('trainer_id'),
                    'name': result.data.get('name'),
                    'is_new': False
                }
            else:
                # New user
                return {
                    'phone_number': phone_number,
                    'is_new': True
                }
                
        except Exception as e:
            log_error(f"Error getting user context: {str(e)}")
            return {'phone_number': phone_number, 'is_new': True}
    
    def _log_interaction(self, phone_number: str, message_data: Dict, response: Dict):
        """Log interaction for analytics"""
        try:
            self.db.table('message_logs').insert({
                'phone_number': phone_number,
                'message_type': message_data.get('type'),
                'message_content': json.dumps(message_data),
                'response': json.dumps(response),
                'timestamp': datetime.now().isoformat()
            }).execute()
        except Exception as e:
            log_error(f"Error logging interaction: {str(e)}")
    
    def _get_help_message(self, user_context: Dict) -> Dict:
        """Get help message"""
        help_text = """ðŸ‹ï¸ *Refiloe Fitness Assistant* ðŸ‹ï¸

Here's what I can help you with:

ðŸ“… *Bookings*
â€¢ "Book a session for tomorrow at 3pm"
â€¢ "Show my upcoming sessions"
â€¢ "Cancel my booking"

ðŸ’ª *Workouts*
â€¢ "Give me a leg workout"
â€¢ "Show chest exercises"
â€¢ "I need a 30-minute workout"

ðŸ“Š *Assessments*
â€¢ "Start my assessment"
â€¢ "Check assessment status"

ðŸ’° *Payments*
â€¢ "Check my balance"
â€¢ "Payment status"

ðŸ“ˆ *Progress Tracking*
â€¢ "Log 2 liters water"
â€¢ "Completed workout"
â€¢ "8 hours sleep"

*Quick Commands:*
/book - Book a session
/workout - Get a workout
/assess - Start assessment
/status - Check your status
/help - Show this message

How can I help you today?"""
        
        return {
            'success': True,
            'message': help_text
        }
    
    def _start_booking_flow(self, from_number: str, user_context: Dict) -> Dict:
        """Start the booking flow"""
        try:
            # Get available slots
            slots = self.scheduler.get_available_slots(
                trainer_id=user_context.get('trainer_id')
            )
            
            if not slots:
                return {
                    'success': True,
                    'message': "No available slots at the moment. Please check back later or contact your trainer directly."
                }
            
            # Format slots message
            message = "ðŸ“… *Available Session Times*\n\n"
            for date, times in slots.items():
                message += f"*{date}*\n"
                for time in times:
                    message += f"â€¢ {time}\n"
                message += "\n"
            
            message += "Reply with your preferred date and time (e.g., 'Tomorrow at 3pm')"
            
            return {
                'success': True,
                'message': message
            }
            
        except Exception as e:
            log_error(f"Error starting booking flow: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't start the booking process."
            }
    
    def _start_workout_flow(self, from_number: str, user_context: Dict) -> Dict:
        """Start workout selection flow"""
        return {
            'success': True,
            'message': "ðŸ’ª *Choose Your Workout Focus*\n\nâ€¢ Chest\nâ€¢ Back\nâ€¢ Legs\nâ€¢ Shoulders\nâ€¢ Arms\nâ€¢ Core\nâ€¢ Full Body\n\nReply with the muscle group you want to work on!",
            'buttons': [
                {'id': 'workout_chest', 'title': 'Chest'},
                {'id': 'workout_legs', 'title': 'Legs'},
                {'id': 'workout_full', 'title': 'Full Body'}
            ]
        }
    
    def _start_assessment_flow(self, from_number: str, user_context: Dict) -> Dict:
        """Start assessment flow"""
        try:
            # Create new assessment
            result = self.assessment.create_assessment(
                trainer_id=user_context.get('trainer_id'),
                client_id=user_context.get('client_id')
            )
            
            if result.get('success'):
                return {
                    'success': True,
                    'message': "ðŸ“‹ *Fitness Assessment Started*\n\nI'll guide you through a series of questions about your health and fitness.\n\nLet's start with your current health status.\n\n*Do you have any medical conditions?*\nReply with any conditions or 'none'"
                }
            else:
                return {
                    'success': False,
                    'message': "Sorry, I couldn't start the assessment."
                }
                
        except Exception as e:
            log_error(f"Error starting assessment: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't start the assessment process."
            }
    
    def _check_payment_status(self, from_number: str, user_context: Dict) -> Dict:
        """Check payment status for user"""
        try:
            # Get payment info
            result = self.db.table('payment_requests').select('*').eq(
                'client_phone', from_number
            ).eq('status', 'pending').execute()
            
            if result.data:
                total = sum([p['amount'] for p in result.data])
                return {
                    'success': True,
                    'message': f"ðŸ’° *Payment Status*\n\nOutstanding: R{total:.2f}\n{len(result.data)} pending payment(s)\n\nYour trainer will send payment details soon."
                }
            else:
                return {
                    'success': True,
                    'message': "âœ… All payments up to date!"
                }
                
        except Exception as e:
            log_error(f"Error checking payment status: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't check your payment status."
            }
    
    def _cancel_current_action(self, user_context: Dict) -> Dict:
        """Cancel current action/flow"""
        # Clear any session state
        return {
            'success': True,
            'message': "âŒ Action cancelled. How else can I help you?"
        }
    
    def _get_user_status(self, from_number: str, user_context: Dict) -> Dict:
        """Get comprehensive user status"""
        try:
            status_parts = []
            
            # Get upcoming bookings
            bookings = self.scheduler.get_client_bookings(from_number)
            if bookings:
                status_parts.append(f"ðŸ“… Next session: {bookings[0]['date']} at {bookings[0]['time']}")
            
            # Get recent workout
            last_workout = self.workout.get_last_workout(user_context.get('client_id'))
            if last_workout:
                status_parts.append(f"ðŸ’ª Last workout: {last_workout['date']}")
            
            # Get assessment status
            assessment = self.assessment.get_latest_assessment(user_context.get('client_id'))
            if assessment:
                status_parts.append(f"ðŸ“‹ Last assessment: {assessment['completed_at'][:10]}")
            
            # Get habit streak
            streak = self.habits.get_current_streak(user_context.get('client_id'))
            if streak:
                status_parts.append(f"ðŸ”¥ Current streak: {streak} days")
            
            if status_parts:
                message = "ðŸ“Š *Your Status*\n\n" + "\n".join(status_parts)
            else:
                message = "Welcome! Let's get started with your fitness journey. Try booking a session or requesting a workout!"
            
            return {
                'success': True,
                'message': message
            }
            
        except Exception as e:
            log_error(f"Error getting user status: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't get your status."
            }
    
    def _handle_button_click(self, button_id: str, user_context: Dict) -> Dict:
        """Handle button click interactions"""
        try:
            if button_id.startswith('workout_'):
                muscle_group = button_id.replace('workout_', '')
                return self._handle_workout_intent(
                    {'entities': {'muscle_group': muscle_group}},
                    user_context.get('phone_number'),
                    user_context
                )
            elif button_id.startswith('book_'):
                # Handle booking selection
                slot = button_id.replace('book_', '')
                return self.scheduler.confirm_booking(slot, user_context)
            else:
                return {
                    'success': False,
                    'message': "I didn't understand that selection."
                }
                
        except Exception as e:
            log_error(f"Error handling button click: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process your selection."
            }
    
    def _handle_list_selection(self, list_id: str, user_context: Dict) -> Dict:
        """Handle list selection interactions"""
        try:
            # Similar to button handling but for list items
            return self._handle_button_click(list_id, user_context)
        except Exception as e:
            log_error(f"Error handling list selection: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process your selection."
            }
    
    def _process_assessment_photo(self, message_data: Dict, user_context: Dict) -> Dict:
        """Process assessment photo submission"""
        try:
            # Store photo reference
            photo_id = message_data.get('image', {}).get('id')
            
            # Update assessment with photo
            self.assessment.add_photo_to_assessment(
                assessment_id=user_context.get('current_assessment_id'),
                photo_id=photo_id,
                photo_type=user_context.get('expected_photo_type', 'general')
            )
            
            return {
                'success': True,
                'message': "ðŸ“¸ Photo received! Continue with your assessment or send another photo."
            }
            
        except Exception as e:
            log_error(f"Error processing assessment photo: {str(e)}")
            return {
                'success': False,
                'message': "Sorry, I couldn't process your photo."
            }

Here is the complete content of app.py: 
import os
import json
import traceback
from datetime import datetime, timedelta
from flask import Flask, request, jsonify, render_template_string
from supabase import create_client
from dotenv import load_dotenv
import pytz

# Import APScheduler for background tasks
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger

# Import services and utilities
from services.whatsapp import WhatsAppService
from services.refiloe import RefiloeService
from services.ai_intent_handler import AIIntentHandler
from services.scheduler import SchedulerService
from services.assessment import EnhancedAssessmentService
from services.habits import HabitTrackingService
from services.workout import WorkoutService
from services.subscription_manager import SubscriptionManager
from services.analytics import AnalyticsService
from models.trainer import Trainer
from models.client import Client
from models.booking import Booking
from utils.logger import setup_logger, log_error, log_info, log_warning
from utils.rate_limiter import RateLimiter
from utils.input_sanitizer import InputSanitizer
from config import Config
from payment_manager import PaymentManager
from payfast_webhook import PayFastWebhookHandler
from voice_helpers import process_voice_note

# Load environment variables
load_dotenv()

# Initialize Flask app
app = Flask(__name__)

# Setup logger
setup_logger()

# Validate configuration
try:
    Config.validate()
    log_info("Configuration validated successfully")
except ValueError as e:
    log_error(f"Configuration error: {str(e)}")
    raise

# Initialize Supabase client
supabase = create_client(Config.SUPABASE_URL, Config.SUPABASE_SERVICE_KEY)

# Initialize services
whatsapp_service = WhatsAppService(Config.ACCESS_TOKEN, Config.PHONE_NUMBER_ID)
refiloe_service = RefiloeService(supabase, Config.ANTHROPIC_API_KEY)
ai_handler = AIIntentHandler(supabase, Config.ANTHROPIC_API_KEY)
scheduler_service = SchedulerService(supabase)
assessment_service = EnhancedAssessmentService(supabase)
habit_service = HabitTrackingService(supabase)
workout_service = WorkoutService(supabase)
subscription_manager = SubscriptionManager(supabase)
analytics_service = AnalyticsService(supabase)
payment_manager = PaymentManager(supabase)
payfast_handler = PayFastWebhookHandler(supabase)
rate_limiter = RateLimiter(supabase)
input_sanitizer = InputSanitizer()

# Initialize background scheduler
scheduler = BackgroundScheduler(timezone=pytz.timezone(Config.TIMEZONE))

def send_daily_reminders():
    """Send daily workout and payment reminders"""
    try:
        log_info("Running daily reminders task")
        
        # Get today's bookings
        today = datetime.now(pytz.timezone(Config.TIMEZONE)).date()
        bookings = scheduler_service.get_bookings_for_date(today)
        
        for booking in bookings:
            # Send reminder 1 hour before session
            session_time = datetime.fromisoformat(booking['session_time'])
            reminder_time = session_time - timedelta(hours=1)
            
            if datetime.now(pytz.timezone(Config.TIMEZONE)) >= reminder_time:
                client_phone = booking['client']['phone_number']
                trainer_name = booking['trainer']['name']
                time_str = session_time.strftime('%I:%M %p')
                
                message = f"ðŸ‹ï¸ Reminder: You have a training session with {trainer_name} at {time_str} today!"
                whatsapp_service.send_message(client_phone, message)
        
        # Check for overdue payments
        overdue_payments = payment_manager.get_overdue_payments()
        for payment in overdue_payments:
            client_phone = payment['client']['phone_number']
            amount = payment['amount']
            days_overdue = payment['days_overdue']
            
            message = f"ðŸ’³ Payment reminder: R{amount} is {days_overdue} days overdue. Please settle your account."
            whatsapp_service.send_message(client_phone, message)
            
        log_info(f"Sent reminders for {len(bookings)} bookings and {len(overdue_payments)} overdue payments")
        
    except Exception as e:
        log_error(f"Error in daily reminders task: {str(e)}")

def check_subscription_status():
    """Check and update subscription statuses"""
    try:
        log_info("Checking subscription statuses")
        expired_count = subscription_manager.check_expired_subscriptions()
        trial_ending_count = subscription_manager.send_trial_ending_reminders()
        
        log_info(f"Processed {expired_count} expired subscriptions and {trial_ending_count} trial endings")
        
    except Exception as e:
        log_error(f"Error checking subscriptions: {str(e)}")

# Schedule background tasks
scheduler.add_job(
    send_daily_reminders,
    CronTrigger(hour=8, minute=0),  # Run at 8 AM daily
    id='daily_reminders',
    replace_existing=True
)

scheduler.add_job(
    check_subscription_status,
    CronTrigger(hour=0, minute=0),  # Run at midnight daily
    id='check_subscriptions',
    replace_existing=True
)

# Start the scheduler
scheduler.start()
log_info("Background scheduler started")

@app.route('/')
def home():
    """Home page"""
    return jsonify({
        "status": "active",
        "service": "Refiloe AI Assistant",
        "version": "2.0",
        "timestamp": datetime.now().isoformat()
    })

@app.route('/health')
def health_check():
    """Health check endpoint"""
    try:
        # Check Supabase connection
        supabase.table('trainers').select('id').limit(1).execute()
        db_status = "connected"
    except:
        db_status = "error"
    
    return jsonify({
        "status": "healthy" if db_status == "connected" else "degraded",
        "database": db_status,
        "timestamp": datetime.now().isoformat()
    })

@app.route('/webhook', methods=['GET', 'POST'])
def webhook():
    """Main WhatsApp webhook endpoint"""
    
    if request.method == 'GET':
        # Webhook verification
        verify_token = request.args.get('hub.verify_token')
        challenge = request.args.get('hub.challenge')
        
        if verify_token == Config.VERIFY_TOKEN:
            log_info("Webhook verified successfully")
            return challenge
        else:
            log_warning("Invalid verification token")
            return 'Invalid verification token', 403
    
    elif request.method == 'POST':
        try:
            # Check rate limits
            if Config.ENABLE_RATE_LIMITING:
                ip_address = request.remote_addr
                if not rate_limiter.check_webhook_rate_limit(ip_address):
                    log_warning(f"Rate limit exceeded for IP: {ip_address}")
                    return jsonify({"error": "Rate limit exceeded"}), 429
            
            # Process webhook data
            data = request.get_json()
            
            if not data:
                return jsonify({"error": "No data provided"}), 400
            
            # Extract message details
            if 'entry' in data:
                for entry in data['entry']:
                    if 'changes' in entry:
                        for change in entry['changes']:
                            if 'value' in change and 'messages' in change['value']:
                                for message in change['value']['messages']:
                                    process_message(message, change['value'].get('contacts', []))
            
            return jsonify({"status": "success"}), 200
            
        except Exception as e:
            log_error(f"Webhook processing error: {str(e)}\n{traceback.format_exc()}")
            return jsonify({"error": "Internal server error"}), 500

def process_message(message: dict, contacts: list):
    """Process incoming WhatsApp message"""
    try:
        from_number = message['from']
        message_type = message.get('type', 'text')
        
        # Check user rate limits
        if Config.ENABLE_RATE_LIMITING:
            if not rate_limiter.check_message_rate_limit(from_number):
                whatsapp_service.send_message(from_number, Config.RATE_LIMIT_MESSAGE)
                return
        
        # Get contact name
        contact_name = "User"
        if contacts:
            contact = next((c for c in contacts if c['wa_id'] == from_number), None)
            if contact:
                contact_name = contact.get('profile', {}).get('name', 'User')
        
        # Handle different message types
        if message_type == 'text':
            text = input_sanitizer.sanitize_text(message['text']['body'])
            handle_text_message(from_number, text, contact_name)
            
        elif message_type == 'audio':
            audio_id = message['audio']['id']
            handle_voice_message(from_number, audio_id, contact_name)
            
        elif message_type == 'interactive':
            handle_interactive_message(from_number, message['interactive'])
            
        elif message_type == 'button':
            handle_button_response(from_number, message['button'])
            
        else:
            whatsapp_service.send_message(
                from_number,
                "I can only process text and voice messages at the moment. Please send me a text or voice note! ðŸ˜Š"
            )
            
    except Exception as e:
        log_error(f"Message processing error: {str(e)}")
        whatsapp_service.send_message(
            from_number,
            "Sorry, I encountered an error processing your message. Please try again."
        )

def handle_text_message(phone_number: str, text: str, contact_name: str):
    """Handle text message"""
    try:
        # Check if user is trainer or client
        user_type, user_data = identify_user(phone_number)
        
        if not user_type:
            # New user - start onboarding
            handle_new_user(phone_number, text, contact_name)
        else:
            # Process message based on user type
            response = ai_handler.process_message(text, phone_number, user_type, user_data)
            
            # Send response
            if response.get('message'):
                whatsapp_service.send_message(phone_number, response['message'])
            
            # Send interactive elements if any
            if response.get('buttons'):
                whatsapp_service.send_interactive_buttons(
                    phone_number,
                    response.get('header', 'Options'),
                    response.get('body', 'Please select:'),
                    response['buttons']
                )
                
    except Exception as e:
        log_error(f"Text message handling error: {str(e)}")
        whatsapp_service.send_message(
            phone_number,
            "Sorry, I couldn't process your message. Please try again."
        )

def handle_voice_message(phone_number: str, audio_id: str, contact_name: str):
    """Handle voice message"""
    try:
        # Check voice note rate limits
        if Config.ENABLE_RATE_LIMITING:
            if not rate_limiter.check_voice_note_rate_limit(phone_number):
                whatsapp_service.send_message(
                    phone_number,
                    "ðŸŽ¤ You're sending voice notes too quickly. Please wait a moment before sending another."
                )
                return
        
        # Process voice note
        transcribed_text = process_voice_note(audio_id, Config.ACCESS_TOKEN)
        
        if transcribed_text:
            # Process as text message
            handle_text_message(phone_number, transcribed_text, contact_name)
        else:
            whatsapp_service.send_message(
                phone_number,
                "Sorry, I couldn't understand your voice message. Please try speaking clearly or send a text message instead."
            )
            
    except Exception as e:
        log_error(f"Voice message handling error: {str(e)}")
        whatsapp_service.send_message(
            phone_number,
            "Sorry, I couldn't process your voice message. Please try again or send a text message."
        )

def handle_interactive_message(phone_number: str, interactive_data: dict):
    """Handle interactive message responses"""
    try:
        response_type = interactive_data.get('type')
        
        if response_type == 'button_reply':
            button_id = interactive_data['button_reply']['id']
            handle_button_click(phone_number, button_id)
            
        elif response_type == 'list_reply':
            list_id = interactive_data['list_reply']['id']
            handle_list_selection(phone_number, list_id)
            
    except Exception as e:
        log_error(f"Interactive message handling error: {str(e)}")

def handle_button_click(phone_number: str, button_id: str):
    """Handle button click from interactive message"""
    try:
        # Process based on button ID
        response = ai_handler.handle_button_action(phone_number, button_id)
        
        if response.get('message'):
            whatsapp_service.send_message(phone_number, response['message'])
            
    except Exception as e:
        log_error(f"Button click handling error: {str(e)}")

def handle_list_selection(phone_number: str, list_id: str):
    """Handle list selection from interactive message"""
    try:
        # Process based on list ID
        response = ai_handler.handle_list_selection(phone_number, list_id)
        
        if response.get('message'):
            whatsapp_service.send_message(phone_number, response['message'])
            
    except Exception as e:
        log_error(f"List selection handling error: {str(e)}")

def handle_button_response(phone_number: str, button_data: dict):
    """Handle button response"""
    try:
        button_text = button_data.get('text', '')
        button_payload = button_data.get('payload', '')
        
        # Process button response
        response = ai_handler.process_button_response(phone_number, button_text, button_payload)
        
        if response.get('message'):
            whatsapp_service.send_message(phone_number, response['message'])
            
    except Exception as e:
        log_error(f"Button response handling error: {str(e)}")

def handle_new_user(phone_number: str, text: str, contact_name: str):
    """Handle new user onboarding"""
    try:
        # Send welcome message
        welcome_message = f"""
ðŸ‘‹ Hi {contact_name}! Welcome to Refiloe - your AI fitness assistant!

I help personal trainers and their clients with:
â€¢ ðŸ“… Booking sessions
â€¢ ðŸ’ª Tracking workouts
â€¢ ðŸ“Š Monitoring progress
â€¢ ðŸ’³ Managing payments
â€¢ ðŸŽ¯ Setting and achieving goals

Are you a:
1ï¸âƒ£ Personal Trainer
2ï¸âƒ£ Client

Please reply with 1 or 2 to get started!
"""
        whatsapp_service.send_message(phone_number, welcome_message)
        
        # Store pending onboarding
        supabase.table('pending_onboarding').insert({
            'phone_number': phone_number,
            'contact_name': contact_name,
            'initial_message': text,
            'created_at': datetime.now().isoformat()
        }).execute()
        
    except Exception as e:
        log_error(f"New user handling error: {str(e)}")

def identify_user(phone_number: str) -> tuple:
    """Identify if user is trainer or client"""
    try:
        # Check trainers table
        trainer = supabase.table('trainers').select('*').eq(
            'phone_number', phone_number
        ).single().execute()
        
        if trainer.data:
            return ('trainer', trainer.data)
        
        # Check clients table
        client = supabase.table('clients').select('*').eq(
            'phone_number', phone_number
        ).single().execute()
        
        if client.data:
            return ('client', client.data)
        
        return (None, None)
        
    except Exception as e:
        log_error(f"User identification error: {str(e)}")
        return (None, None)

@app.route('/webhook/payfast', methods=['POST'])
def payfast_webhook():
    """Handle PayFast payment webhooks"""
    try:
        # Get webhook data
        data = request.form.to_dict()
        signature = request.headers.get('X-PayFast-Signature', '')
        
        # Verify signature
        if not payment_manager.verify_webhook_signature(data, signature):
            log_warning("Invalid PayFast signature")
            return 'Invalid signature', 403
        
        # Process webhook
        result = payfast_handler.process_webhook(data)
        
        if result['success']:
            return 'OK', 200
        else:
            return 'Processing failed', 500
            
    except Exception as e:
        log_error(f"PayFast webhook error: {str(e)}")
        return 'Internal error', 500

@app.route('/dashboard')
def dashboard():
    """Simple web dashboard for trainers"""
    if not Config.ENABLE_WEB_DASHBOARD:
        return "Dashboard is disabled", 404
    
    # Import dashboard routes
    from routes.dashboard import dashboard_bp
    app.register_blueprint(dashboard_bp, url_prefix='/dashboard')
    
    return render_template_string("""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Refiloe Dashboard</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            h1 { color: #333; }
            .status { padding: 10px; background: #e8f5e9; border-radius: 5px; }
        </style>
    </head>
    <body>
        <h1>Refiloe AI Assistant Dashboard</h1>
        <div class="status">
            <p>âœ… System is running</p>
            <p>ðŸ“Š View your analytics and manage clients</p>
        </div>
    </body>
    </html>
    """)

@app.errorhandler(404)
def not_found(e):
    """Handle 404 errors"""
    return jsonify({"error": "Endpoint not found"}), 404

@app.errorhandler(500)
def server_error(e):
    """Handle 500 errors"""
    log_error(f"Server error: {str(e)}")
    return jsonify({"error": "Internal server error"}), 500

# Cleanup scheduler on shutdown
import atexit
atexit.register(lambda: scheduler.shutdown(wait=False))

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    debug = os.environ.get('FLASK_ENV') == 'development'
    
    log_info(f"Starting Refiloe AI Assistant on port {port}")
    app.run(host='0.0.0.0', port=port, debug=debug)

The app crashed again. Here are the logs: 
Traceback (most recent call last):
  File "/app/app.py", line 16, in <module>
    from services.refiloe import RefiloeService
  File "/app/services/refiloe.py", line 12, in <module>
    from services.habits import HabitTrackingService
ImportError: cannot import name 'HabitTrackingService' from 'services.habits' (/app/services/habits.py)
